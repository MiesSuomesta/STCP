#![allow(dead_code)]

use core::ffi::{c_void, c_int, c_ulong};

use crate::ctx::{get_or_init_ctx, free_ctx, with_lock};
use crate::error::{ENOMEM, ENOTTY, ENOPROTOOPT, EINVAL};

//
// Init: kutsutaan kun socketille halutaan Rust-konteksti
//
#[no_mangle]
pub extern "C" fn stcp_rust_init(sk: *mut c_void) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
    }
    0
}

#[no_mangle]
pub extern "C" fn stcp_rust_close(sk: *mut c_void, _timeout: i64) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if !ctx.is_null() {
            with_lock(sk, |c| c.on_close());
            free_ctx_for_socket(sk);
        }
    }
    0
}

#[no_mangle]
pub extern "C" fn stcp_rust_bind(
    sk: *mut c_void,
    uaddr: *const c_void,
    addr_len: c_int,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        with_lock(sk, |c| c.on_bind(uaddr, addr_len));
    }
    0
}

#[no_mangle]
pub extern "C" fn stcp_rust_listen(sk: *mut c_void, _backlog: c_int) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        with_lock(sk, |c| c.on_listen());
    }
    0
}

#[no_mangle]
pub extern "C" fn stcp_rust_connect(
    sk: *mut c_void,
    uaddr: *const c_void,
    addr_len: c_int,
    flags: c_int,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        let mut rc: c_int = 0;
        with_lock(sk, |c| {
            rc = c.on_connect_client(uaddr, addr_len, flags);
        });
        rc
    }
}

#[no_mangle]
pub extern "C" fn stcp_rust_accept(
    new_sk: *mut c_void,
    _lsk: *mut c_void,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(new_sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        with_lock(new_sk, |c| c.on_accept_server(_lsk));
    }
    0
}

#[no_mangle]
pub extern "C" fn stcp_rust_getname(
    sk: *mut c_void,
    uaddr: *mut c_void,
    addr_len: *mut c_int,
    peer: c_int,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        with_lock(sk, |c| c.on_getname(uaddr, addr_len, peer));
    }
    0
}

#[no_mangle]
pub extern "C" fn stcp_rust_sendmsg(
    sk: *mut c_void,
    msg: *mut c_void,
    flags: c_int,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        let mut rc: c_int = 0;
        with_lock(sk, |c| {
            rc = c.on_sendmsg(msg, flags);
        });
        rc
    }
}

#[no_mangle]
pub extern "C" fn stcp_rust_recvmsg(
    sk: *mut c_void,
    msg: *mut c_void,
    len: usize,
    flags: c_int,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        let mut rc: c_int = 0;
        with_lock(sk, |c| {
            rc = c.on_recvmsg(msg, len, flags);
        });
        rc
    }
}

#[no_mangle]
pub extern "C" fn stcp_rust_setsockopt(
    sk: *mut c_void,
    level: c_int,
    optname: c_int,
    optval: *const c_void,
    optlen: c_int,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        let mut rc: c_int = 0;
        with_lock(sk, |c| {
            rc = c.on_setsockopt(level, optname, optval, optlen);
        });
        rc
    }
}

#[no_mangle]
pub extern "C" fn stcp_rust_getsockopt(
    sk: *mut c_void,
    level: c_int,
    optname: c_int,
    optval: *mut c_void,
    optlen: *mut c_int,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOMEM;
        }
        let mut rc: c_int = 0;
        with_lock(sk, |c| {
            rc = c.on_getsockopt(level, optname, optval, optlen);
        });
        rc
    }
}

#[no_mangle]
pub extern "C" fn stcp_rust_poll(
    sk: *mut c_void,
    file: *mut c_void,
    wait: *mut c_void,
) -> u32 {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return 0;
        }
        let mut mask: u32 = 0;
        with_lock(sk, |c| {
            mask = c.on_poll(file, wait);
        });
        mask
    }
}

#[no_mangle]
pub extern "C" fn stcp_rust_ioctl(
    sk: *mut c_void,
    cmd: c_ulong,
    arg: c_ulong,
) -> c_int {
    unsafe {
        let ctx = get_or_init_ctx(sk);
        if ctx.is_null() {
            return -ENOTTY;
        }
        let mut rc: c_int = 0;
        with_lock(sk, |c| {
            rc = c.on_ioctl(cmd, arg);
        });
        rc
    }
}
